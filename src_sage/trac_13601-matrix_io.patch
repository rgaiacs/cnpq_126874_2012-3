# HG changeset patch
# User Raniere Silva <r.gaia.cs@gmail.com>
# Date 1350337996 10800
# Node ID 2cdf82afac2e6a2e2b095bcd8b7204de1300c2bd
# Parent  c95c1ffa8aff73e6055bf82919815d93bf66d1a8
Version 0.1 of matrix_io.

diff --git a/doc/en/reference/matrices.rst b/doc/en/reference/matrices.rst
--- a/doc/en/reference/matrices.rst
+++ b/doc/en/reference/matrices.rst
@@ -52,6 +52,8 @@
 
    sage/matrix/constructor
 
+   sage/matrix/matrix_io
+
    sage/matrix/docs
 
    sage/matrix/matrix
diff --git a/sage/matrix/all.py b/sage/matrix/all.py
--- a/sage/matrix/all.py
+++ b/sage/matrix/all.py
@@ -1,5 +1,6 @@
 from matrix_space import MatrixSpace, is_MatrixSpace
 from constructor import matrix, Matrix, column_matrix, random_matrix, diagonal_matrix, identity_matrix, block_matrix, block_diagonal_matrix, jordan_block, zero_matrix, ones_matrix, elementary_matrix, companion_matrix
+from matrix_io import load_matrix, write_matrix
 from matrix import is_Matrix
 from berlekamp_massey import berlekamp_massey
 
diff --git a/sage/matrix/matrix_io.py b/sage/matrix/matrix_io.py
new file mode 100644
--- /dev/null
+++ b/sage/matrix/matrix_io.py
@@ -0,0 +1,930 @@
+"""
+Matrix input and output
+
+This file has many functions for input and output of matrices.
+
+REFERENCES:
+
+.. [Numpy] Numpy Reference, Input and output. http://docs.scipy.org/doc/numpy/reference/routines.io.html
+
+.. [Scipy] Scipy v.011 Reference Guide (Draft). Input and output http://docs.scipy.org/doc/scipy/reference/io.html
+
+.. [OCTAVE] GNU Octave, Simple File I/O. http://www.gnu.org/software/octave/doc/interpreter/Simple-File-I_002fO.html
+
+.. [CTF] Coordinate Text File. http://math.nist.gov/MatrixMarket/formats.html
+
+.. [HDF5] HDF5: API Specification Reference Manual. http://www.hdfgroup.org/HDF5/doc/RM/RM_H5Front.html
+
+.. [MMEF] Matrix Market Exchange Formats. http://math.nist.gov/MatrixMarket/formats.html
+
+.. [HBEF] Harwell-Boeing Exchange Format. http://math.nist.gov/MatrixMarket/formats.html
+
+.. [MFF] MAT-File Format. http://www.mathworks.com/help/pdf_doc/matlab/matfile_format.pdf
+
+.. [LPSOLVE] MPS file format. http://lpsolve.sourceforge.net/5.5/mps-format.htm
+
+AUTHORS:
+
+- Raniere Silva (2012)
+"""
+
+#*****************************************************************************
+#       Copyright (C) 2005 William Stein <wstein@gmail.com>
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#    This code is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#    General Public License for more details.
+#
+#  The full text of the GPL is available at:
+#
+#                  http://www.gnu.org/licenses/
+#*****************************************************************************
+from constructor import *
+from sage.rings.all import RR
+
+def load_matrix(file_name, file_format=None):
+    """Load matrices from file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    - ``file_format`` - string specify the format of the file to be load. If no
+      format is specify will be used the extension of the file.
+
+      ======= ========== ====================================================
+      Format  Extensions Mean
+      ======= ========== ====================================================
+      ascii   txt        A single matrix in a text file without header or any
+                         other information. (*)
+      ctf     ctf        Coordinate Text File. (*)
+      oct     oct        Octave's binary data format. (*)
+      f-oct   f-oct      Octave's binary data format but only using single
+                         precision. (*)
+      t-oct   t-oct      Octave's text data format. (*)
+      hdf5    hdf5       hdf5 format. (HDF5 is a free,
+                         portable binary format developed by the National
+                         Center for Supercomputing Applications at the
+                         University of Illinois.) (*)
+      f-hdf5  f-hdf5     hdf5 format but only using single
+                         precision. (*)
+      mm      mm         The Matrix Market (MM) exchange formats. (*)
+      hb      hb         The Harwell-Boeing format. (*)
+      mat7    m          matlab's v7 binary data format.
+      mat6               matlab's v6 binary data format.
+      mat4               matlab's v5 binary data format.
+      idl     sav        IDL save file.
+      mps     mps        Mathematical Programming System (a file format for
+                         presenting and archiving linear programming (LP)
+                         and mixed integer programming problems.
+      ======= ========== ====================================================
+
+      (*) Mean that is not implemented yet.
+
+    OUTPUT:
+
+    Dictionary of matrices.
+
+    EXAMPLES::
+
+        sage: mdict = load_matrix('tests/data/testprob.mps')
+        sage: mdict['A']
+        [ 1.0  1.0  0.0]
+        [ 1.0  0.0  1.0]
+        [ 0.0 -1.0  1.0]
+        sage: mdict['b']
+        (5.00000000000000, 10.0000000000000, 7.00000000000000)
+        sage: mdict['c']
+        (1.00000000000000, 4.00000000000000, 9.00000000000000)
+        sage: mdict['rows_type']
+        (-1, 1, 0)
+        sage: mdict['l']
+        (0.0, -1.0, 0.0)
+        sage: mdict['u']
+        (4.0, 1.0, +infinity)
+        sage: mdict['cols_type']
+        (0, 0, 0)
+
+    .. NOTE::
+
+        The porpouse of this function is to be a easy way to get matrix (and
+        vectors) from files. In some case the it be possible to some
+        information present in the file be lost.
+
+    .. WARNING::
+
+        This function is a prototype and isn't finish.
+
+    .. TODO::
+
+       * Implement the ascii handle.
+       * Implement the ctf handle.
+       * Implement the oct handle.
+       * Implement the f-oct handle.
+       * Implement the t-oct handle.
+       * Implement the hdf5 handle.
+       * Implement the f-hdf5 handle.
+       * Implement the mm handle.
+       * Implement the hb handle.
+
+    AUTHORS:
+
+    - Raniere Silva (2012): first implementation.
+    """
+
+    if file_format == None:
+        file_format = file_name.split('.')[-1]
+    if file_format in ['ascii', 'txt']:
+        mdict = _load_mps(file_name)
+    elif file_format in ['oct']:
+        mdict = _load_oct(file_name)
+    elif file_format in ['f-oct']:
+        mdict = _load_foct(file_name)
+    elif file_format in ['t-oct']:
+        mdict = _load_toct(file_name)
+    elif file_format in ['hdf5']:
+        mdict = _load_hdf5(file_name)
+    elif file_format in ['f-hdf5']:
+        mdict = _load_fhdf5(file_name)
+    elif file_format in ['mm']:
+        mdict = _load_mm(file_name)
+    elif file_format in ['hb']:
+        mdict = _load_hb(file_name)
+    # WARNING Maybe is best split the Matlab formats.
+    elif file_format in ['m', 'mat7', 'mat6', 'mat4']:
+        mdict = _load_m(file_name)
+    elif file_format in ['sav']:
+        mdict = _load_sav(file_name)
+    elif file_format in ['mps']:
+        return _load_mps(file_name)
+    else:
+        if file_format == '':
+            raise ValueError("Can't discovery the file format.")
+        else:
+            raise ValueError("File format is not support.")
+    return mdict
+
+def _load_ascii(file_name):
+    """Load matrix from ascii file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+        * 'A' - the matrix.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read ascii format.")
+
+def _load_ctf(file_name):
+    """Load matrix from ctf file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read ctf format.")
+
+def _load_oct(file_name):
+    """Load matrices from oct file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read oct format.")
+
+def _load_foct(file_name):
+    """Load matrices from f-oct file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read f-oct format.")
+
+def _load_toct(file_name):
+    """Load matrices from t-oct file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read t-oct format.")
+
+def _load_hdf5(file_name):
+    """Load matrices from hdf5 file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read hdf5 format.")
+
+def _load_fhdf5(file_name):
+    """Load matrices from f-hdf5 file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read f-hdf5 format.")
+
+def _load_mm(file_name):
+    """Load matrices from mm file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read mm format.")
+
+def _load_hb(file_name):
+    """Load matrices from hb file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read hb format.")
+
+def _load_m(file_name):
+    """Load matrices from m file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): first implementation.
+    """
+    import scipy.io
+
+    m = scipy.io.loadmat(file_name)
+    mdict = {}
+    for k in m.keys():
+        if not k.startswith('__'):
+            try:
+                mdict[k] = matrix(m[k])
+            except:
+                pass
+    return mdict
+
+def _load_sav(file_name):
+    """Load matrices from sav file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): first implementation.
+    """
+    import scipy.io
+
+    m = scipy.io.readsav(file_name)
+    mdict = {}
+    for k in m.keys():
+        try:
+            mdict[k] = matrix(m[k])
+        except:
+            pass
+    return mdict
+
+def _load_mps(file_name):
+    """Load matrices from mps file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrices:
+
+        * 'A' - the coeficient matrix (sparse).
+        * 'b' - the rhs vector (sparse).
+        * 'c' - the cost vector (sparse).
+        * 'rows_type' - type of rows (dense).
+        * 'l' - lower bound (dense).
+        * 'u' - upper bound (dense).
+        * 'cols_type' - type of columns (dense).
+
+    EXAMPLES::
+
+        sage: mdict = load_matrix('tests/data/testprob.mps')
+        sage: mdict['A']
+        [ 1.0  1.0  0.0]
+        [ 1.0  0.0  1.0]
+        [ 0.0 -1.0  1.0]
+        sage: mdict['b']
+        (5.00000000000000, 10.0000000000000, 7.00000000000000)
+        sage: mdict['c']
+        (1.00000000000000, 4.00000000000000, 9.00000000000000)
+        sage: mdict['rows_type']
+        (-1, 1, 0)
+        sage: mdict['l']
+        (0.0, -1.0, 0.0)
+        sage: mdict['u']
+        (4.0, 1.0, +infinity)
+        sage: mdict['cols_type']
+        (0, 0, 0)
+        sage: mdict = load_matrix('tests/data/sos2test.mps')
+        sage: mdict['A']
+        [-1.0  1.0  1.0 10.0  0.0]
+        [ 1.0 -3.0  1.0  0.0  0.0]
+        [ 0.0  1.0  0.0 -3.5  0.0]
+        sage: mdict['b']
+        (30.0000000000000, 30.0000000000000, 0.000000000000000)
+        sage: mdict['c']
+        (-1.00000000000000, -2.00000000000000, -3.00000000000000, -1.00000000000000, 0.000000000000000)
+        sage: mdict['rows_type']
+        (-1, -1, 0)
+        sage: mdict['l']
+        (0.0, 0.0, 0.0, 2.0, 0.0)
+        sage: mdict['u']
+        (40.0, +infinity, +infinity, 3.0, +infinity)
+        sage: mdict['cols_type']
+        (0, 0, 0, 1, 0)
+
+    .. WARNING::
+
+        This function can't process semi-cont variable, rows type and ranges
+        yet.
+
+    .. TODO::
+
+        * Implement the semi-cont variable.
+        * Implement the range parse.
+        * Implement the sos parse.
+
+    AUTHORS:
+
+    - Raniere Silva (2012): first implementation.
+    """
+    with open(file_name, 'r') as f:
+        in_rows = False
+        in_cols = False
+        in_rhs = False
+        in_rng = False
+        in_bnd = False
+        in_sos = False
+        process = False
+        # rows is a dictionary of the names of the rows that store the row
+        # number atribute to the row's name.
+        rows = {}
+        n_rows = -1
+        # cols is a dictionary of the names of the columns that store the
+        # column number atribute to the column's name.
+        cols = {}
+        n_cols = -1
+        # A is a dictionary representing the sparse coeficient matrix.
+        A = {}
+        # c is a dictionary representing the sparse cost vector.
+        c = {}
+        # b is a dictionary representing the sparse rhs vector.
+        b = {}
+        # l is a list representing the lower bound.
+        l = None
+        # u is a list representing the upper bound.
+        u = None
+        # cols_type is a list representing the type of column.
+        cols_type = None
+        # rows_type is a list representing the type of column.
+        # ===== =====================
+        # type      meaning
+        # ===== =====================
+        # 0     equality
+        # -1    less than or equal
+        #  1    greater than or equal
+        rows_type = None
+        for line in f:
+            # Line to be treated as a comment starts with '*'.
+            if not line.startswith('*'):
+                if line[0] != ' ':
+                    p = line.split()
+                    if p[0].upper() == 'NAME':
+                        process = False
+                    elif p[0].upper() == 'ROWS':
+                        process = False
+                        in_rows = True
+                        in_cols = in_rhs = in_rng = in_bnd = in_sos = False
+                    elif p[0].upper() == 'COLUMNS':
+                        process = False
+                        in_cols = True
+                        in_rows = in_rhs = in_rng = in_bnd = in_sos = False
+
+                        # Build the rows_tye.
+                        rows_type = [0 for i in xrange(n_rows + 1)]
+                        for k in rows.keys():
+                            if rows[k][1] == 'E':
+                                rows_type[rows[k][0]] = 0
+                            elif rows[k][1] == 'L':
+                                rows_type[rows[k][0]] = -1
+                            elif rows[k][1] == 'G':
+                                rows_type[rows[k][0]] = 1
+                    elif p[0].upper() == 'RHS':
+                        process = False
+                        in_rhs = True
+                        in_rows = in_cols = in_rng = in_bnd = in_sos = False
+                        # The variables must be set where to avoid problems.
+                        l = [0 for i in xrange(n_cols + 1)]
+                        u = [float('inf') for i in xrange(n_cols + 1)]
+                        cols_type = [0 for i in xrange(n_cols + 1)]
+                    elif p[0].upper() == 'RANGES':
+                        process = False
+                        in_rng = True
+                        in_rows = in_cols = in_rhs = in_bnd = in_sos = False
+                    elif p[0].upper() == 'BOUNDS':
+                        process = False
+                        in_bnd = True
+                        in_rows = in_cols = in_rhs = in_rng = in_sos = False
+                    elif p[0].upper() == 'SOS':
+                        process = False
+                        in_sos = True
+                        in_rows = in_cols = in_rhs = in_rng = in_bnd = False
+                    elif p[0].upper() == 'ENDATA':
+                        process = False
+                else:
+                    p = line.split()
+                    if in_rows:
+                        if p[0] == 'N':
+                            rows[p[1]] = (None, p[0])
+                        else:
+                            n_rows += 1
+                            rows[p[1]] = (n_rows, p[0])
+                    elif in_cols:
+                        if p[0] in cols.keys():
+                            j = cols[p[0]]
+                        else:
+                            n_cols += 1
+                            cols[p[0]] = n_cols
+                            j = n_cols
+                        for i_aux in xrange(1, len(p), 2):
+                            i = rows[p[i_aux]][0]
+                            if i >= 0:
+                                A[(i, j)] = float(p[i_aux + 1])
+                            else:
+                                c[j] = float(p[i_aux + 1])
+                    elif in_rhs:
+                        for i_aux in xrange(1, len(p), 2):
+                            b[rows[p[i_aux]][0]] = float(p[i_aux + 1])
+                    elif in_rng:
+                        pass
+                    elif in_bnd:
+                        i = cols[p[2]]
+                        if p[0] == 'LO':
+                            l[i] = float(p[3])
+                        elif p[0] == 'UP':
+                            u[i] = float(p[3])
+                        elif p[0] == 'FX':
+                            l[i] = float(p[3])
+                            u[i] = float(p[3])
+                        elif p[0] == 'FR':
+                            l[i] = -Infinity
+                            u[i] = Infinity
+                        elif p[0] == 'MI':
+                            l[i] = -Infinity
+                            u[i] = 0
+                        elif p[0] == 'PL':
+                            l[i] = 0
+                            u[i] = Infinity
+                        elif p[0] == 'BV':
+                            l[i] = 0
+                            u[i] = 1
+                            cols_type[i] = 1
+                        elif p[0] == 'LI':
+                            l[i] = float(p[3])
+                            cols_type[i] = 1
+                        elif p[0] == 'UI':
+                            u[i] = float(p[3])
+                            cols_type[i] = 1
+                    elif in_sos:
+                        pass
+        return {'A': matrix(n_rows + 1, n_cols + 1, A),
+                'b': vector(RR, n_rows + 1, b),
+                'c': vector(RR, n_cols + 1, c),
+                'l': vector(l),
+                'u': vector(u),
+                'rows_type': vector(rows_type),
+                'cols_type': vector(cols_type)}
+
+def write_matrix(mdict, file_name, file_format=None):
+    """Write matrices to file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    - ``file_format`` - string specify the format of the file to be write. If no
+      format is specify will be used the extension of the file.
+
+      ======= ========== ====================================================
+      Format  Extensions Mean
+      ======= ========== ====================================================
+      ascii   txt        A single matrix in a text file without header or any
+                         other information. (*)
+      ctf     ctf        Coordinate Text File. (*)
+      oct     oct        Octave's binary data format. (*)
+      f-oct   f-oct      Octave's binary data format but only using single
+                         precision. (*)
+      t-oct   t-oct      Octave's text data format. (*)
+      hdf5    hdf5       hdf5 format. (HDF5 is a free,
+                         portable binary format developed by the National
+                         Center for Supercomputing Applications at the
+                         University of Illinois.) (*)
+      f-hdf5  f-hdf5     hdf5 format but only using single
+                         precision. (*)
+      mm      mm         The Matrix Market (MM) exchange formats. (*)
+      hb      hb         The Harwell-Boeing format. (*)
+      mat7    m          matlab's v7 binary data format. (*)
+      mat6               matlab's v6 binary data format. (*)
+      mat4               matlab's v5 binary data format. (*)
+      idl     sav        IDL save file. (*)
+      mps     mps        Mathematical Programming System (a file format for
+                         presenting and archiving linear programming (LP)
+                         and mixed integer programming problems. (*)
+      ======= ========== ====================================================
+
+      (*) Mean that is not implemented yet.
+
+    EXAMPLES:
+
+    .. NOTE::
+
+        The porpouse of this function is to be a easy way to get matrix (and
+        vectors) from files. In some case the it be possible to some
+        information present in the file be lost.
+
+    .. WARNING::
+
+        This function is a prototype and isn't finish.
+
+    .. TODO::
+
+       * Implement the ascii handle.
+       * Implement the ctf handle.
+       * Implement the oct handle.
+       * Implement the f-oct handle.
+       * Implement the t-oct handle.
+       * Implement the hdf5 handle.
+       * Implement the f-hdf5 handle.
+       * Implement the mm handle.
+       * Implement the hb handle.
+       * Implement the m handle.
+       * Implement the sav handle.
+       * Implement the mps handle.
+
+    AUTHORS:
+
+    - Raniere Silva (2012): first implementation.
+    """
+
+    if file_format == None:
+        file_format = file_name.split('.')[-1]
+    if file_format in ['ascii', 'txt']:
+        mdict = _write_mps(mdict, file_name)
+    elif file_format in ['oct']:
+        mdict = _write_oct(mdict, file_name)
+    elif file_format in ['f-oct']:
+        mdict = _write_foct(mdict, file_name)
+    elif file_format in ['t-oct']:
+        mdict = _write_toct(mdict, file_name)
+    elif file_format in ['hdf5']:
+        mdict = _write_hdf5(mdict, file_name)
+    elif file_format in ['f-hdf5']:
+        mdict = _write_fhdf5(mdict, file_name)
+    elif file_format in ['mm']:
+        mdict = _write_mm(mdict, file_name)
+    elif file_format in ['hb']:
+        mdict = _write_hb(mdict, file_name)
+    # WARNING Maybe is best split the Matlab formats.
+    elif file_format in ['m', 'mat7', 'mat6', 'mat4']:
+        mdict = _write_m(mdict, file_name)
+    elif file_format in ['sav']:
+        mdict = _write_sav(mdict, file_name)
+    elif file_format in ['mps']:
+        return _write_mps(mdict, file_name)
+    else:
+        if file_format == '':
+            raise ValueError("Can't discovery the file format.")
+        else:
+            raise ValueError("File format is not support.")
+
+def _write_ascii(mdict, file_name):
+    """Write matrix from ascii file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be load.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't write ascii format.")
+
+def _write_ctf(mdict, file_name):
+    """Write matrix from ctf file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read ctf format.")
+
+def _write_oct(mdict, file_name):
+    """Write matrices from oct file.
+
+    INPUT:
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read oct format.")
+
+def _write_foct(file_name):
+    """Write matrix from f-oct file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read f-oct format.")
+
+def _write_toct(file_name):
+    """Write matrices from t-oct file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read t-oct format.")
+
+def _write_hdf5(mdict, file_name):
+    """Write matrices from hdf5 file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read hdf5 format.")
+
+def _write_fhdf5(mdict, file_name):
+    """Write matrix from f-hdf5 file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read f-hdf5 format.")
+
+def _write_mm(mdict, file_name):
+    """Write matrix from mm file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read mm format.")
+
+def _write_hb(mdict, file_name):
+    """Write matrix from hb file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't read hb format.")
+
+def _write_m(mdict, file_name):
+    """Write matrix from m file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't write m format.")
+
+def _write_sav(mdict, file_name):
+    """Write matrix from sav file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't write sav format.")
+
+def _write_mps(mdict, file_name):
+    """Write matrix from mps file.
+
+    INPUT:
+
+    - ``mdict`` - dictionary where the values are matrices.
+
+        * 'A' - the coeficient matrix (sparse).
+        * 'b' - the rhs vector (sparse).
+        * 'c' - the cost vector (sparse).
+        * 'rows_type' - type of rows (dense).
+        * 'l' - lower bound (dense).
+        * 'u' - upper bound (dense).
+        * 'cols_type' - type of columns (dense).
+
+    - ``file_name`` - name of the file to be write.
+
+    EXAMPLES:
+
+    AUTHORS:
+
+    - Raniere Silva (2012): function declaration.
+    """
+    raise NotImplementedError("Can't write mps format.")
diff --git a/sage/matrix/tests/data/sos2test.mps b/sage/matrix/tests/data/sos2test.mps
new file mode 100644
--- /dev/null
+++ b/sage/matrix/tests/data/sos2test.mps
@@ -0,0 +1,29 @@
+NAME          SOS2test
+ROWS
+ N  obj
+ L  c1
+ L  c2
+ E  c3
+COLUMNS
+    x1        obj                 -1   c1                  -1
+    x1        c2                   1
+    x2        obj                 -2   c1                   1
+    x2        c2                  -3   c3                   1
+    x3        obj                 -3   c1                   1
+    x3        c2                   1
+    x4        obj                 -1   c1                  10
+    x4        c3                -3.5
+    x5        obj                  0
+RHS
+    rhs       c1                  30   c2                  30
+BOUNDS
+ UP BOUND     x1                  40
+ LI BOUND     x4                   2
+ UI BOUND     x4                   3
+SOS
+ S2 SET       SOS2                10
+    SET       x1               10000
+    SET       x2               20000
+    SET       x4               40000
+    SET       x5               50000
+ENDATA
diff --git a/sage/matrix/tests/data/testprob.mps b/sage/matrix/tests/data/testprob.mps
new file mode 100644
--- /dev/null
+++ b/sage/matrix/tests/data/testprob.mps
@@ -0,0 +1,21 @@
+NAME          TESTPROB
+ROWS
+ N  COST
+ L  LIM1
+ G  LIM2
+ E  MYEQN
+COLUMNS
+    XONE      COST                 1   LIM1                 1
+    XONE      LIM2                 1
+    YTWO      COST                 4   LIM1                 1
+    YTWO      MYEQN               -1
+    ZTHREE    COST                 9   LIM2                 1
+    ZTHREE    MYEQN                1
+RHS
+    RHS1      LIM1                 5   LIM2                10
+    RHS1      MYEQN                7
+BOUNDS
+ UP BND1      XONE                 4
+ LO BND1      YTWO                -1
+ UP BND1      YTWO                 1
+ENDATA
