# HG changeset patch
# User Raniere Silva <r.gaia.cs@gmail.com>
# Date 1349815418 10800
# Node ID c1dfc5adb46be3b686d48beb67a078ebb6fcfa42
# Parent  00d38cb9d6f792153cf95d716a8f00f064fb9445
Prototype of the function load_matrix and _load_mps.

diff --git a/sage/matrix/all.py b/sage/matrix/all.py
--- a/sage/matrix/all.py
+++ b/sage/matrix/all.py
@@ -1,5 +1,5 @@
 from matrix_space import MatrixSpace, is_MatrixSpace
-from constructor import matrix, Matrix, column_matrix, random_matrix, diagonal_matrix, identity_matrix, block_matrix, block_diagonal_matrix, jordan_block, zero_matrix, ones_matrix, elementary_matrix, companion_matrix
+from constructor import matrix, Matrix, column_matrix, random_matrix, diagonal_matrix, identity_matrix, block_matrix, block_diagonal_matrix, jordan_block, zero_matrix, ones_matrix, elementary_matrix, companion_matrix, load_matrix
 from matrix import is_Matrix
 from berlekamp_massey import berlekamp_massey
 
diff --git a/sage/matrix/constructor.py b/sage/matrix/constructor.py
--- a/sage/matrix/constructor.py
+++ b/sage/matrix/constructor.py
@@ -3956,5 +3956,270 @@
     entries.update({(j,j):aa, (j,i):bb, (i,j):-bb, (i,i):aa})
     return matrix(entries, nrows=dim, ring=ring)
 
-
-
+def load_matrix(f_name, f_format=None):
+    """Load matrix from file.
+
+    INPUT:
+
+    - ``f_name`` - name of the file to be load.
+
+    - ``f_format`` - string specify the format of the file to be load. If no
+      format is specify will be used the extension of the file.
+
+      ======= ========== ====================================================
+      Format  Extensions Mean
+      ======= ========== ====================================================
+      ascii   txt        A single matrix in a text file without header or any
+                         other information. (*)
+      oct     oct        Octave's binary data format. (*)
+      f-oct   f-oct      Octave's binary data format but only using single
+                         precision. (*)
+      t-oct   t-oct      Save the data in Octave's text data format. (*)
+      hdf5    hdf5       Save the data in hdf5 format. (HDF5 is a free,
+                         portable binary format developed by the National
+                         Center for Supercomputing Applications at the
+                         University of Illinois.) (*)
+      f-hdf5  f-hdf5     Save the data in hdf5 format but only using single
+                         precision. (*)
+      mat7    m          Save the data in matlab's v7 binary data format. (*)
+      mat6               Save the data in matlab's v6 binary data format. (*)
+      mat4               Save the data in matlab's v5 binary data format. (*)
+      mps     mps        Mathematical Programming System (a file format for
+                         presenting and archiving linear programming (LP) 
+                         and mixed integer programming problems
+      ======= ========== ====================================================
+
+      (*) Mean that is not implemented yet.
+
+    OUTPUT:
+
+    Dictionary of matrixs.
+
+    EXAMPLES::
+
+    .. NOTE::
+
+        The porpouse of this function is to be a easy way to get matrix (and
+        vectors) from files. In some case the it be possible to some
+        information present in the file be lost.
+
+    .. WARNING::
+
+        This function is a prototype and isn't finish.
+
+    .. TODO::
+    
+        Implement the ascii handle.
+
+        Implement the oct handle.
+
+        Implement the f-oct handle.
+
+        Implement the t-oct handle.
+
+        Implement the hdf5 handle.
+
+        Implement the f-hdf5 handle.
+
+    REFERENCES:
+
+        .. [OCTAVE] GNU Octave, Simple File I/O.
+
+    AUTHORS:
+
+    - Raniere Silva (2012)
+    """
+    import scipy.io
+
+    if f_format == None:
+        f_format = f_name.split('.')[-1]
+    if f_format in ['ascii', 'txt']:
+        raise NotImplementedError("Can't read ascii format.")
+    elif f_format in ['oct']:
+        raise NotImplementedError("Can't read oct format.")
+    elif f_format in ['f-oct']:
+        raise NotImplementedError("Can't read f-oct format.")
+    elif f_format in ['t-oct']:
+        raise NotImplementedError("Can't read t-oct format.")
+    elif f_format in ['hdf5']:
+        raise NotImplementedError("Can't read hdf5 format.")
+    elif f_format in ['f-hdf5']:
+        raise NotImplementedError("Can't read f-hdf5 format.")
+    # WARNING Maybe is best split the Matlab formats.
+    elif f_format in ['m', 'mat7', 'mat6', 'mat4']:
+        m = scipy.io.loadmat(f_name)
+        d = {}
+        for k in m.keys():
+            if not k.startswith('__'):
+                try:
+                    d[k] = matrix(m[k])
+                except:
+                    pass
+        return d
+    elif f_format in ['mps']:
+        return _load_mps_matrix(f_name)
+    else:
+        if f_format == '':
+            raise ValueError("Can't discovery the file format.")
+        else:
+            raise ValueError("File format is not support.")
+
+def _load_mps_matrix(f_name):
+    """Load matrix from mps file.
+
+    INPUT:
+
+    - ``f_name`` - name of the file to be load.
+
+    OUTPUT:
+
+    Dictionary of matrixs:
+
+        * 'A' - the coeficient matrix (sparse).
+        * 'b' - the rhs vector (sparse).
+        * 'c' - the cost vector (sparse).
+        * 'rows_type' - type of rows (dense).
+        * 'l' - lower bound (dense).
+        * 'u' - upper bound (dense).
+        * 'cols_type' - type of columns (dense).
+
+    EXAMPLES::
+
+    .. WARNING::
+
+        This function can't process semi-cont variable, rows type and ranges
+        yet.
+
+    .. TODO::
+
+        Implement the semi-cont variable.
+
+        Implement the range parse.
+
+    REFERENCES:
+
+        .. [LPSOLVE] `MPS file format
+        <http://lpsolve.sourceforge.net/5.5/mps-format.htm>`_
+
+    AUTHORS:
+
+    - Raniere Silva (2012)
+    """
+    with open(f_name, 'r') as f:
+        in_rows = False
+        in_cols = False
+        in_rhs = False
+        in_bnd = False
+        process = False
+        # rows is a dictionary of the names of the rows that store the row
+        # number atribute to the row's name.
+        rows = {}
+        n_rows = -1
+        # cols is a dictionary of the names of the columns that store the
+        # column number atribute to the column's name.
+        cols = {}
+        n_cols = -1
+        # A is a dictionary representing the sparse coeficient matrix.
+        A = {}
+        # c is a dictionary representing the sparse cost vector.
+        c = {}
+        # b is a dictionary representing the sparse rhs vector.
+        b = {}
+        # l is a list representing the lower bound.
+        l = None
+        # u is a list representing the upper bound.
+        u = None
+        # cols_type is a list representing the type of column.
+        cols_type = None
+        # rows_type is a list representing the type of column.
+        # rows_type = None
+        for line in f:
+            # Line to be treated as a comment starts with '*'.
+            if not line.startswith('*'):
+                process = True
+                p = line.split()
+                if p[0].upper() == 'NAME':
+                    process = False
+                elif p[0].upper() == 'ROWS':
+                    process = False
+                    in_rows = True
+                    in_cols = in_rhs = in_bnd = False
+                elif p[0].upper() == 'COLUMNS':
+                    process = False
+                    in_cols = True
+                    in_rows = in_rhs = in_bnd = False
+                elif p[0].upper() == 'RHS':
+                    process = False
+                    in_rhs = True
+                    in_rows = in_cols = in_bnd = False
+                elif p[0].upper() == 'RANGES':
+                    process = False
+                elif p[0].upper() == 'BOUNDS':
+                    process = False
+                    in_bnd = True
+                    in_rows = in_cols = in_rhs = False
+                    l = [0 for i in xrange(n_cols)]
+                    u = [float('inf') for i in xrange(n_cols)]
+                    cols_type = [0 for i in xrange(n_cols)]
+                elif p[0].upper() == 'SOS':
+                    process = False
+                elif p[0].upper() == 'ENDATA':
+                    process = False
+                if process:
+                    if in_rows:
+                        if p[0] == 'N':
+                            rows[p[1]] = (None, p[0])
+                        else:
+                            n_rows += 1
+                            rows[p[1]] = (n_rows, p[0])
+                    elif in_cols:
+                        if p[0] in cols.keys():
+                            j = cols[p[0]]
+                        else:
+                            n_cols += 1
+                            cols[p[0]] = n_cols
+                            j = n_cols
+                        for i_aux in xrange(1, len(p), 2):
+                            i = rows[p[i_aux]][0]
+                            if i:
+                                A[(rows[p[i_aux]][0], j)] = float(p[i_aux + 1])
+                            else:
+                                c[j] = float(p[i_aux + 1])
+                    elif in_rhs:
+                        for i_aux in xrange(1, len(p), 2):
+                            b[rows[p[i_aux]][0]] = float(p[i_aux + 1])
+                    elif in_bnd:
+                        i = cols[p[2]]
+                        if p[0] == 'LO':
+                            l[i] = float(p[3])
+                        elif p[0] == 'UP':
+                            u[i] = float(p[3])
+                        elif p[0] == 'FX':
+                            l[i] = float(p[3])
+                            u[i] = float(p[3])
+                        elif p[0] == 'FR':
+                            l[i] = -Infinity
+                            u[i] = Infinity
+                        elif p[0] == 'MI':
+                            l[i] = -Infinity
+                            u[i] = 0
+                        elif p[0] == 'PL':
+                            l[i] = 0
+                            u[i] = Infinity
+                        elif p[0] == 'BV':
+                            l[i] = 0
+                            u[i] = 1
+                            t[i] = 1
+                        elif p[0] == 'LI':
+                            l[i] = float(p[3])
+                            t[i] = 1
+                        elif p[0] == 'UI':
+                            u[i] = float(p[3])
+                            t[i] = 1
+        return {'A': matrix(A),
+                'b': vector(b),
+                'c': vector(c),
+                'l': matrix(l),
+                'u': matrix(u),
+                # 'rows_type': matrix(rows_type),
+                'cols_type': matrix(cols_type)}
